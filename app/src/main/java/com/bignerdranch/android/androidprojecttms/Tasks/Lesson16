ПРАКТИКА
0. Создать новый проект в Android Studio и добавить его на гит:
New Project -> Empty Activity -> указываем имя, пакет
VCS -> Enable Vercison Controle Integration -> Git
Git -> GitHub -> Share project on GitHub -> указываем имя -> Share -> указываем
название коммита (можно оставить Initial commit) -> Add
В дальнейшем можно каждый шаг/два коммитить и пушить.
1. Создать новый Kotlin класс: Discount с полями title, description, discountAmount,
imageUrl, siteUrl. Добавить поля в конструктор класса.
2. Добавить свой getter для title (переводит в большие буквы) и setter для description
(обрезает строку до 100 символов).
3. Сделать класс Discount data классом (getter и setter из пп.2 превратить в новые
функции, т.е. data класс не поддерживает переопределенные getter и setter).
4. Добавить в файл *Activity (или в любой новый файл) функцию main(). В этой
функции создать экземпляр класса Discount и напечатать его в консоль (println).
Запустить функцию main().
4*. Если убратьк data из класса Discount, то при выводе не будет выведены поля
класса, а только номер класса. Т.е. функция toString() (а также equals(), hashCode(),
componentN() и copy()) не сгенерированы.
5. В метод main() добавить создание нового экземпляра класса Discount с помощью
метода copy(). Вывести в консоль сравнение экземляров с помощью == и я ее
6. Создать enum class DiscountType. 2 типа: FlatAmount и RangeAmount.
Переопределить метод toString(), в котором с помощью when выводить различный
текст для разного дискаунта.
7. В класс Discount добавить поле DiscountType. В методе main для созданного и
скопированного объекта Discount, установить разные значения поля DiscountType.
Вывести объекты в консоль.
8. Переделать enum DiscountType в sealed class: FlatAmount и RangeAmount станут
data классами: FlatAmount с полем value, RangeAmount со startValue и endValue. Плюс
добавим object NoDiscount. Все 3 должны наследоваться от DiscountType. Метод
toString адаптировать.
9. В main создать 3-й объект типа Discount (можно как копию любого ранее созданного)
с новым типом DiscountType. Вывести и 3-й объект в консоль.
10. В sealed класс DiscountType добавить параметр: поле функционального типа,
получающее Int на входе и возвращающее String
val calculate: (Int)->String
FlatAmount, RangeAmount и NoDiscount должны добавить функцию в вызов
конструктора родительского DiscountType.
FlatAmont в теле функции умножает полученное значение на свое поле value
(результат преобразовывает в строку), RangeAmount умножает полученное значение
на среднее арифметическое полей startValue и endValue (произведение тоже
переводим в строку), NoDiscount просто возвращает 0 в виде строки.
11. В main добавляем для 3-х объектов Discount с 3-мя разными значениями поля
discountType активацию функционального типа calculate с одинаковым параметром.
Результат выводим в консоль:
println(discount.discountType.calculate(5))
Делаем еще один коммит и пуш в основную ветку.
Домашнее задание
Создается новая ветка, в нее коммитится весь код, а после пуша создается пул
реквест в основную ветку. Ссылку на этот ПР скидываем мне.
12. Создать новый класс Order с произвольными параметрами, которые посчитаете
нужными для сущности Заказ. Обязательно лишь поле address.
13. Создать sealed class Delivery и хотя бы 3 класса наследника.
14. У Delivery добавить поле функционального типа deliver, получающее в качестве
входного параметра Order без возвращающего типа
val deliver: (Order)->Unit
Наследники класса Delivery в вызов родительского конструктора добавляют функцию в
качестве параметра, в теле которой каждый по своему выводит в консоль получаемый
объект Order.
15. В main создаем список из 3-х объектов класса Order и массив из 3-х объектов
класса Delivery.
16. Для каждого Order из списка активизируем поле deliver функционального типа у
каждого из объектов Delivery (т.е. должно быть 9 вызовов функционального типа
deliver. Это легко можно сделать с помощью функции forEach для обоих списков из пп.
15.
17*. Делаем в sealed классе Delivery поле deliver функционального типа мутабельным
(val меняем на var).
В main после кода из пп 16 устанавливаем в один (или несколько) объектов типа
Delivery новое значение в поле функционального типа deliver.
И еще раз добавляем код из пп. 16.
Чтобы убедиться, что для измененной доставки вывелся измененный текст в консоль.